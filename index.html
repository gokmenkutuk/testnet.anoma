<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Shrimp Racer - Collect Balls, Avoid Obstacles</title>
  <style>
    :root {
      --bg: #0b0e1a;
      --road: #141a2c;
      --white: #f5f5f5;
      --lane: var(--white);
      --text: #e7eaf6;
      --pass: #7cfc00;
      --fail: #ff6b6b;
      --blue: #4aa3ff;
      --red: #ff5a5a;
      --yellow: #ffd54a;
      --obs-color: #FFB347; /* Light orange obstacle color */
    }
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: linear-gradient(180deg, var(--bg), #11162a);
      color: var(--text);
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 10px;
    }
    header {
      width: min(920px, 100%);
      padding: 10px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .pill {
      background: #121735;
      border: 1px solid #26305a;
      padding: 6px 12px;
      border-radius: 999px;
      font-weight: 700;
      white-space: nowrap;
      font-size: 14px;
    }
    .pill.score-info {
      order: 1;
      text-align: center;
      flex-grow: 1;
    }
    #wrap {
      position: relative;
      width: min(920px, 100%);
      max-width: 450px;
      aspect-ratio: 9/16;
      background: var(--road);
      border: 1px solid #26305a;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      margin: 10px 0;
    }
    #game {
      width: 100%;
      height: 100%;
      display: block;
    }
    .status-panel {
      position: absolute;
      left: 10px;
      bottom: 10px;
      background: rgba(15, 20, 48, 0.8);
      border: 1px solid #2b3569;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 12px;
      backdrop-filter: blur(6px);
      z-index: 10;
    }
    .banner {
      right: 10px;
      bottom: 10px;
      top: unset;
      left: unset;
    }
    .center-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      padding: 20px;
      text-align: center;
      z-index: 20;
    }
    .card {
      pointer-events: auto;
      background: rgba(15, 20, 48, 0.9);
      border: 1px solid #2b3569;
      padding: 24px;
      border-radius: 16px;
      width: min(520px, 100%);
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    }
    .title {
      font-size: 26px;
      font-weight: 900;
      margin: 0 0 12px;
      line-height: 1.2;
    }
    .end-btns, .start-btn {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
    }
    .btn {
      cursor: pointer;
      font-size: 16px;
      font-weight: 800;
      color: var(--text);
      border-color: #5dacec;
      transition: transform 0.1s ease;
      background: #4aa3ff;
      padding: 10px 20px;
      border-radius: 999px;
      border: 1px solid transparent;
    }
    .btn:hover {
      transform: translateY(-2px);
    }
    #continue-btn {
      background: #45a049;
      border-color: #5cb85c;
    }
    #exit-btn {
      background: #dc3545;
      border-color: #c82333;
    }
    #how-to-play-visual {
      position: relative;
      font-size: 50px;
      margin-bottom: 20px;
      display: inline-block;
    }
    #how-to-play-visual::before {
      content: '‚õëÔ∏è';
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 40px;
      color: #ffd54a;
    }
    .flicker {
      animation: flicker 0.2s infinite alternate;
    }
    @keyframes flicker {
      from { opacity: 1; }
      to { opacity: 0.2; }
    }
    .audio-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
    }
    .audio-btn {
      background: #4aa3ff;
      color: var(--text);
      border: 1px solid #5dacec;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.1s ease;
    }
    .audio-btn:hover {
      transform: scale(1.05);
    }
    #volume-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 80px;
      height: 8px;
      background: #5dacec;
      border-radius: 5px;
      outline: none;
      opacity: 0.7;
      transition: opacity .2s;
    }
    #volume-slider:hover {
      opacity: 1;
    }
    #volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #4aa3ff;
      border: 1px solid var(--text);
      border-radius: 50%;
      cursor: pointer;
    }
    #volume-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #4aa3ff;
      border: 1px solid var(--text);
      border-radius: 50%;
      cursor: pointer;
    }
    /* Kayan ≈üarkƒ± adƒ± i√ßin yeni stil */
    #song-title {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(15, 20, 48, 0.8);
      padding: 8px;
      text-align: center;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      box-shadow: 0 -2px 5px rgba(0,0,0,0.3);
    }
    .marquee-text {
      display: inline-block;
      padding-left: 100%; /* Metnin tam ekran dƒ±≈üƒ±ndan ba≈ülamasƒ± i√ßin */
      animation: marquee 15s linear infinite;
    }
    @keyframes marquee {
      0% { transform: translate(0, 0); }
      100% { transform: translate(-100%, 0); }
    }
  </style>
</head>
<body>
  <header>
    <div class="pill">
      ‚Üê/‚Üí: Change Lane
    </div>
    <div class="pill score-info">
      Target: <b>200</b> Points
    </div>
    <div class="pill">
      Points ‚Äî Yellow:50 ‚Ä¢ Red:10 ‚Ä¢ Blue:2.5 ‚Ä¢ White:1
    </div>
    <div class="audio-controls">
      <!-- M√ºzik kontrolleri g√∂rseldeki d√ºzene g√∂re yeniden sƒ±ralandƒ± -->
      <button id="prevBtn" class="audio-btn">
        <!-- √ñnceki ≈üarkƒ± butonu SVG'si d√ºzeltildi -->
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
          <path d="M6 18V6h2v12H6zM18 18L9.5 12 18 6v12z"/>
        </svg>
      </button>
      <button id="playPauseBtn" class="audio-btn">
        <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
          <path d="M8 5v14l11-7z"/>
        </svg>
        <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="display: none;">
          <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
        </svg>
      </button>
      <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
      <button id="nextBtn" class="audio-btn">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
          <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
        </svg>
      </button>
    </div>
  </header>
  <main id="wrap">
    <canvas id="game"></canvas>
    <div id="endOverlay" class="center-overlay" style="display: none">
      <div class="card">
        <p class="title" id="endTitle"></p>
        <p id="endStats"></p>
        <div class="end-btns">
          <button id="continue-btn" class="btn" style="display: none;">Continue</button>
          <button id="retry-btn" class="btn">Retry</button>
          <button id="exit-btn" class="btn">Exit</button>
        </div>
      </div>
    </div>

    <div id="howToPlayOverlay" class="center-overlay" style="display: flex">
      <div class="card">
        <h2 class="title">How to Play</h2>
        <div id="how-to-play-visual">ü¶ê</div>
        <p>Use the left and right arrow keys to move your shrimp between lanes.</p>
        <p>Collect balls, avoid orange obstacles!</p>
        <div class="start-btn">
          <button id="startButton" class="btn">Start!</button>
        </div>
      </div>
    </div>
    <div id="song-title">
        <span class="marquee-text" id="songTitleText"></span>
    </div>
  </main>
  <footer>
    <p style="font-size: 12px; opacity: 0.7; margin-top: 20px;">
      Powered by a simple Canvas game engine.
    </p>
  </footer>

  <script>
    (() => {
      // --- Game Constants and State ---
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      let W = 0, H = 0, laneW = 0, laneX = [];
      const LANES = 3;
      const TARGET_SCORE = 200;

      let score = 0;
      let lives = 3;
      let speed = 0.5;
      
      const speedIncreaseScores = [4, 15, 50, 75, 150, 175];
      let nextSpeedIncreaseIndex = 0;
      const SPEED_INCREASE_AMOUNT = 0.2;
      const MAX_SPEED = 3.5;

      // --- Player State ---
      const player = { lane: 1, y: 0, w: 0, h: 0, isInvulnerable: false, x: 0, targetX: 0 };
      let invulnerabilityTimer = 0;
      const invulnerabilityDuration = 3000;

      // --- Collectible (Ball) Types ---
      const BALLS = [
        { name: 'white', color: '--white', score: 1, weight: 170 / 200 },
        { name: 'blue', color: '--blue', score: 2.5, weight: 20 / 200 },
        { name: 'red', color: '--red', score: 10, weight: 9 / 200 },
        { name: 'yellow', color: '--yellow', score: 50, weight: 1 / 200 },
      ];
      const totalWeight = BALLS.reduce((sum, ball) => sum + ball.weight, 0);
      BALLS.forEach(ball => ball.p = ball.weight / totalWeight);
      const drops = []; // balls and obstacles

      // --- Spawning Timers ---
      let ballSpawnTimer = 0, ballSpawnPeriod = 700;
      let obstacleSpawnTimer = 0, obstacleSpawnPeriod = 800;

      // --- Drawing Helpers ---
      const cssColors = new Map();
      function getCssVar(name) {
        if (!cssColors.has(name)) {
          cssColors.set(name, getComputedStyle(document.documentElement).getPropertyValue(name).trim());
        }
        return cssColors.get(name);
      }

      function drawBackground() {
        ctx.fillStyle = getCssVar('--road');
        ctx.fillRect(0, 0, W, H);
        ctx.strokeStyle = getCssVar('--lane');
        ctx.lineWidth = 4;
        ctx.setLineDash([18, 18]);
        for (let i = 1; i < LANES; i++) {
          const x = laneX[i] - (laneX[i] - laneX[i - 1]) / 2;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, H);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      function drawBall(x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(x + r * 0.35, y - r * 0.35, r * 0.55, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      function drawObstacle(x, y, h, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.rect(x - laneW / 2, y - h / 2, laneW, h); 
        ctx.fill();
      }

      function fmt(n) {
        return Number.isInteger(n) ? n.toString() : n.toFixed(1);
      }

      function resize() {
        const wrap = document.getElementById('wrap');
        const rect = wrap.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        W = rect.width;
        H = rect.height;
        laneW = Math.floor(W * 0.22);
        const gap = (W - laneW * LANES) / (LANES + 1);
        laneX = Array.from({ length: LANES }, (_, i) => Math.floor(gap + i * (laneW + gap)) + laneW / 2);
        player.w = laneW * 0.9;
        player.h = player.w;
        player.y = H - player.h - 30;
        player.x = laneX[player.lane];
        player.targetX = laneX[player.lane];
      }
      window.addEventListener('resize', resize);
      window.addEventListener('orientationchange', resize);

      // --- Player (Shrimp) Logic ---
      function moveLane(dir) {
        if (running) {
          player.lane = Math.max(0, Math.min(LANES - 1, player.lane + dir));
          player.x = laneX[player.lane];
          player.targetX = laneX[player.lane];
        }
      }
      window.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') moveLane(-1);
        if (e.key === 'ArrowRight') moveLane(1);
      });
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touchX = e.touches[0].clientX;
        if (touchX < W / 2) {
          moveLane(-1);
        } else {
          moveLane(1);
        }
      });
      
      // --- Spawning and Movement Logic ---
      function rngKind() {
        const r = Math.random();
        let acc = 0;
        for (const b of BALLS) {
          acc += b.p;
          if (r <= acc) return b;
        }
        return BALLS[BALLS.length - 1];
      }

      function spawnBall() {
        const lane = Math.floor(Math.random() * LANES);
        const kind = rngKind();
        const dropRadius = Math.max(10, laneW * 0.12);
        drops.push({ type: 'ball', lane, y: -dropRadius, r: dropRadius, kind });
      }

      function spawnObstacle() {
        const obsHeight = Math.max(20, laneW * 0.2);
        if (Math.random() < 0.25) {
          const lane1 = Math.floor(Math.random() * LANES);
          let lane2 = Math.floor(Math.random() * LANES);
          while(lane2 === lane1) {
            lane2 = Math.floor(Math.random() * LANES);
          }
          drops.push({ type: 'obstacle', lane: lane1, y: -obsHeight, h: obsHeight });
          drops.push({ type: 'obstacle', lane: lane2, y: -obsHeight, h: obsHeight });
        } else {
          const lane = Math.floor(Math.random() * LANES);
          drops.push({ type: 'obstacle', lane, y: -obsHeight, h: obsHeight });
        }
        obstacleSpawnPeriod = 700 + Math.random() * 500;
      }

      // --- Game Over / Win Logic ---
      const endOverlay = document.getElementById('endOverlay');
      const howToPlayOverlay = document.getElementById('howToPlayOverlay');
      const startButton = document.getElementById('startButton');
      const endTitle = document.getElementById('endTitle');
      const endStats = document.getElementById('endStats');
      const retryBtn = document.getElementById('retry-btn');
      const continueBtn = document.getElementById('continue-btn');
      const exitBtn = document.getElementById('exit-btn');

      startButton.addEventListener('click', () => { reset(); });
      retryBtn.addEventListener('click', () => { reset(); });
      continueBtn.addEventListener('click', () => { continueGame(); });
      exitBtn.addEventListener('click', () => {
        endOverlay.style.display = 'none';
        howToPlayOverlay.style.display = 'flex';
        running = false;
      });

      function showGameOver() {
        endTitle.textContent = 'Game Over!';
        endStats.textContent = `Your Score: ${fmt(score * 10)}`;
        continueBtn.style.display = 'none';
        endOverlay.style.display = 'flex';
        running = false; // Stop the game loop
      }
      
      function showWin() {
        endTitle.textContent = 'Congratulations, You Reached the Target!';
        endStats.textContent = `You passed 200 points! Your total score: ${fmt(score * 10)}`;
        continueBtn.style.display = 'inline-block';
        endOverlay.style.display = 'flex';
        running = false; // Stop the game loop
      }

      // --- Game Loop and Core Logic ---
      let running = false, lastTime = 0;
      let animationFrameId = null;

      function reset() {
        // Cancel any existing animation frame to prevent multiple loops
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }

        running = true;
        lastTime = performance.now();
        score = 0;
        lives = 3;
        speed = 0.5;
        nextSpeedIncreaseIndex = 0;
        drops.length = 0;
        player.isInvulnerable = false;
        invulnerabilityTimer = 0;
        howToPlayOverlay.style.display = 'none';
        endOverlay.style.display = 'none';

        // Reset player to the middle lane (lane 1)
        player.lane = 1; 

        resize();
        
        // Start a fresh game loop
        animationFrameId = requestAnimationFrame(loop);
      }

      function continueGame() {
        // Stop any previous game loop
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        
        running = true;
        lastTime = performance.now();
        score = 0;
        speed = 0.5;
        nextSpeedIncreaseIndex = 0;
        drops.length = 0;
        player.isInvulnerable = false;
        invulnerabilityTimer = 0;
        endOverlay.style.display = 'none';

        // Reset player to the middle lane (lane 1)
        player.lane = 1;

        resize();
        animationFrameId = requestAnimationFrame(loop);
      }

      function loop(t) {
        if (!running) {
            // If the game is not running, stop the loop.
            // This is a safety check. The loop should be canceled when the game ends.
            return;
        }

        const dt = Math.min(32, (t || performance.now()) - lastTime);
        lastTime = t || performance.now();

        if (player.isInvulnerable) {
          invulnerabilityTimer += dt;
          if (invulnerabilityTimer >= invulnerabilityDuration) {
            player.isInvulnerable = false;
            invulnerabilityTimer = 0;
          }
        }

        ballSpawnTimer += dt;
        if (ballSpawnTimer >= ballSpawnPeriod) {
          spawnBall();
          ballSpawnTimer = 0;
        }
        obstacleSpawnTimer += dt;
        if (obstacleSpawnTimer >= obstacleSpawnPeriod) {
          spawnObstacle();
          obstacleSpawnTimer = 0;
        }

        const vy = (speed * dt * H) / 700;
        for (const d of drops) {
          d.y += vy;
        }

        const py = player.y + player.h * 0.5;
        const pr = Math.min(player.w, player.h) * 0.4;
        
        for (let i = drops.length - 1; i >= 0; i--) {
          const d = drops[i];
          if (d.lane === player.lane) {
            let collided = false;
            if (d.type === 'ball') {
              const dist = Math.hypot(laneX[d.lane] - player.x, d.y - py);
              collided = dist < d.r + pr;
            } else if (d.type === 'obstacle') {
              const obsY = d.y + d.h / 2;
              const obsHalfHeight = d.h / 2;
              collided = Math.abs(py - obsY) < (pr + obsHalfHeight);
            }
            
            if (collided) {
              if (d.type === 'ball') {
                score += d.kind.score;
                drops.splice(i, 1);
                
                if (nextSpeedIncreaseIndex < speedIncreaseScores.length && score >= speedIncreaseScores[nextSpeedIncreaseIndex]) {
                  speed = Math.min(MAX_SPEED, speed + SPEED_INCREASE_AMOUNT);
                  nextSpeedIncreaseIndex++;
                }

              } else if (d.type === 'obstacle') {
                if (!player.isInvulnerable) {
                  lives--;
                  player.isInvulnerable = true;
                  invulnerabilityTimer = 0;
                  if (lives <= 0) {
                    showGameOver();
                    cancelAnimationFrame(animationFrameId); // Immediately cancel next loop
                    return; 
                  }
                }
              }
            }
          }
        }

        for (let i = drops.length - 1; i >= 0; i--) {
          if (drops[i].y > H + drops[i].r) {
            drops.splice(i, 1);
          }
        }

        if (score >= TARGET_SCORE) {
          showWin();
          cancelAnimationFrame(animationFrameId); // Immediately cancel next loop
          return;
        }

        ctx.clearRect(0, 0, W, H);
        drawBackground();
        
        const pY = player.y + player.h * 0.5;

        if (!player.isInvulnerable || (player.isInvulnerable && invulnerabilityTimer % 200 < 100)) {
          ctx.fillStyle = getCssVar('--text');
          ctx.font = `bold ${player.w * 0.7}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('ü¶ê', player.x, pY);
        }
        
        for (const d of drops) {
          if (d.type === 'ball') {
            drawBall(laneX[d.lane], d.y, d.r, getCssVar(d.kind.color));
          } else if (d.type === 'obstacle') {
            drawObstacle(laneX[d.lane], d.y, d.h, getCssVar('--obs-color'));
          }
        }

        ctx.fillStyle = getCssVar('--text');
        ctx.font = 'bold 16px system-ui';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(`Score: ${fmt(score)} / ${TARGET_SCORE}`, 12, 22);
        ctx.fillText(`Lives: ${lives}`, 12, 44);

        if (running) {
          animationFrameId = requestAnimationFrame(loop);
        }
      }
      
      // --- M√ºzik Kontrol√º ve √áalma Listesi ---
      const playlist = [
        { path: "assets/The Blaze - Territory.mp3", title: "The Blaze - Territory" },
        { path: "assets/Gorillaz - Feel Good Inc. (Official Video).mp3", title: "Gorillaz - Feel Good Inc." },
        { path: "assets/Summit.mp3", title: "Summit" },
      ];
      let currentTrackIndex = 0;
      
      const audio = new Audio(playlist[currentTrackIndex].path);
      audio.loop = true;
      
      const playPauseBtn = document.getElementById('playPauseBtn');
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      const playIcon = document.getElementById('playIcon');
      const pauseIcon = document.getElementById('pauseIcon');
      const volumeSlider = document.getElementById('volume-slider');
      const songTitleText = document.getElementById('songTitleText');
      let isPlaying = false;
      
      function togglePlayPause() {
        if (isPlaying) {
          audio.pause();
          playIcon.style.display = 'block';
          pauseIcon.style.display = 'none';
        } else {
          audio.play().catch(e => console.error("Ses oynatma hatasƒ±:", e));
          playIcon.style.display = 'none';
          pauseIcon.style.display = 'block';
        }
        isPlaying = !isPlaying;
      }
      
      function playNextTrack() {
        currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
        audio.src = playlist[currentTrackIndex].path;
        audio.load();
        if (isPlaying) {
          audio.play().catch(e => console.error("Ses oynatma hatasƒ±:", e));
        }
        updateSongTitleDisplay();
      }

      function playPreviousTrack() {
        currentTrackIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
        audio.src = playlist[currentTrackIndex].path;
        audio.load();
        if (isPlaying) {
          audio.play().catch(e => console.error("Ses oynatma hatasƒ±:", e));
        }
        updateSongTitleDisplay();
      }

      function updateSongTitleDisplay() {
        songTitleText.textContent = playlist[currentTrackIndex].title;
      }
      
      playPauseBtn.addEventListener('click', togglePlayPause);
      nextBtn.addEventListener('click', playNextTrack);
      prevBtn.addEventListener('click', playPreviousTrack);
      
      volumeSlider.addEventListener('input', (e) => {
        audio.volume = e.target.value;
      });

      startButton.addEventListener('click', () => {
        reset();
        if (!isPlaying) {
          audio.play().catch(e => console.error("Oyun ba≈ülangƒ±cƒ±nda ses oynatma hatasƒ±:", e));
          playIcon.style.display = 'none';
          pauseIcon.style.display = 'block';
          isPlaying = true;
        }
        updateSongTitleDisplay();
      });
      
      resize();
      updateSongTitleDisplay();
    })();
  </script>
</body>
</html>
