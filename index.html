<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Shrimp Racer - Collect Balls, Avoid Obstacles</title>
  <style>
    :root {
      --bg: #0b0e1a;
      --road: #141a2c;
      --white: #f5f5f5;
      --lane: var(--white);
      --text: #e7eaf6;
      --pass: #7cfc00;
      --fail: #ff6b6b;
      --blue: #4aa3ff;
      --red: #ff5a5a;
      --yellow: #ffd54a;
      --obs-color: #FFB347; /* Light orange obstacle color */
    }
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: linear-gradient(180deg, var(--bg), #11162a);
      color: var(--text);
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 10px;
    }
    header {
      width: min(920px, 100%);
      padding: 10px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: center;
    }
    .pill {
      background: #121735;
      border: 1px solid #26305a;
      padding: 6px 12px;
      border-radius: 999px;
      font-weight: 700;
      white-space: nowrap;
      font-size: 14px;
    }
    .pill.score-info {
      order: 1;
      text-align: center;
      flex-grow: 1;
    }
    #wrap {
      position: relative;
      width: min(920px, 100%);
      max-width: 450px;
      aspect-ratio: 9/16;
      background: var(--road);
      border: 1px solid #26305a;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      margin: 10px 0;
    }
    #game {
      width: 100%;
      height: 100%;
      display: block;
    }
    .status-panel {
      position: absolute;
      left: 10px;
      bottom: 10px;
      background: rgba(15, 20, 48, 0.8);
      border: 1px solid #2b3569;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 12px;
      backdrop-filter: blur(6px);
      z-index: 10;
    }
    .banner {
      right: 10px;
      bottom: 10px;
      top: unset;
      left: unset;
    }
    .center-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      padding: 20px;
      text-align: center;
      z-index: 20;
    }
    .card {
      pointer-events: auto;
      background: rgba(15, 20, 48, 0.9);
      border: 1px solid #2b3569;
      padding: 24px;
      border-radius: 16px;
      width: min(520px, 100%);
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    }
    .title {
      font-size: 26px;
      font-weight: 900;
      margin: 0 0 12px;
      line-height: 1.2;
    }
    .end-btns, .start-btn {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
    }
    .btn {
      cursor: pointer;
      font-size: 16px;
      font-weight: 800;
      color: var(--text);
      border-color: #5dacec;
      transition: transform 0.1s ease;
      background: #4aa3ff;
      padding: 10px 20px;
      border-radius: 999px;
      border: 1px solid transparent;
    }
    .btn:hover {
      transform: translateY(-2px);
    }
    #continue-btn {
      background: #45a049;
      border-color: #5cb85c;
    }
    #exit-btn {
      background: #dc3545;
      border-color: #c82333;
    }
    #how-to-play-visual {
      position: relative;
      font-size: 50px;
      margin-bottom: 20px;
      display: inline-block;
    }
    #how-to-play-visual::before {
      content: '‚õëÔ∏è';
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 40px;
      color: #ffd54a;
    }
    .flicker {
      animation: flicker 0.2s infinite alternate;
    }
    @keyframes flicker {
      from { opacity: 1; }
      to { opacity: 0.2; }
    }
  </style>
</head>
<body>
  <header>
    <div class="pill">
      ‚Üê/‚Üí: Change lane
    </div>
    <div class="pill score-info">
      Goal: <b>200</b> Points
    </div>
    <div class="pill">
      Points ‚Äî Yellow:50 ‚Ä¢ Red:10 ‚Ä¢ Blue:2.5 ‚Ä¢ White:1
    </div>
  </header>
  <main id="wrap">
    <canvas id="game"></canvas>
    <div id="endOverlay" class="center-overlay" style="display: none">
      <div class="card">
        <p class="title" id="endTitle"></p>
        <p id="endStats"></p>
        <div class="end-btns">
          <button id="continue-btn" class="btn" style="display: none;">Continue</button>
          <button id="retry-btn" class="btn">Play Again</button>
          <button id="exit-btn" class="btn">Exit</button>
        </div>
      </div>
    </div>

    <div id="howToPlayOverlay" class="center-overlay" style="display: flex">
      <div class="card">
        <h2 class="title">How to Play?</h2>
        <div id="how-to-play-visual">ü¶ê</div>
        <p>Move your shrimp between lanes using the left and right arrow keys.</p>
        <p>Collect balls, avoid orange obstacles!</p>
        <div class="start-btn">
          <button id="startButton" class="btn">Start!</button>
        </div>
      </div>
    </div>
  </main>
  <footer>
    <p style="font-size: 12px; opacity: 0.7; margin-top: 20px;">
      Powered by a simple Canvas game engine.
    </p>
  </footer>

  <script>
    (() => {
      // --- Game Constants and State ---
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      let W = 0, H = 0, laneW = 0, laneX = [];
      const LANES = 3;
      const TARGET_SCORE = 200;

      let score = 0;
      let lives = 3;
      let speed = 0.5; // Initial speed
      
      // Speed increases based on score.
      const speedIncreaseScores = [4, 15, 50, 75, 150, 175];
      let nextSpeedIncreaseIndex = 0;
      const SPEED_INCREASE_AMOUNT = 0.2; // Increase amount
      const MAX_SPEED = 3.5; // Maximum speed

      // --- Player State ---
      const player = { lane: 1, y: 0, w: 0, h: 0, isInvulnerable: false, x: 0, targetX: 0 };
      let invulnerabilityTimer = 0;
      const invulnerabilityDuration = 3000; // 3 seconds

      // --- Collectible (Ball) Types ---
      const BALLS = [
        // Weights updated. Red and yellow ball counts slightly reduced.
        { name: 'white', color: '--white', score: 1, weight: 170 / 200 },
        { name: 'blue', color: '--blue', score: 2.5, weight: 20 / 200 },
        { name: 'red', color: '--red', score: 10, weight: 9 / 200 },
        { name: 'yellow', color: '--yellow', score: 50, weight: 1 / 200 },
      ];
      const totalWeight = BALLS.reduce((sum, ball) => sum + ball.weight, 0);
      BALLS.forEach(ball => ball.p = ball.weight / totalWeight);
      const drops = []; // balls and obstacles

      // --- Spawning Timers ---
      let ballSpawnTimer = 0, ballSpawnPeriod = 700;
      let obstacleSpawnTimer = 0, obstacleSpawnPeriod = 800; // More frequent and random obstacles

      // --- Drawing Helpers ---
      const cssColors = new Map();
      function getCssVar(name) {
        if (!cssColors.has(name)) {
          cssColors.set(name, getComputedStyle(document.documentElement).getPropertyValue(name).trim());
        }
        return cssColors.get(name);
      }

      function drawBackground() {
        ctx.fillStyle = getCssVar('--road');
        ctx.fillRect(0, 0, W, H);
        ctx.strokeStyle = getCssVar('--lane');
        ctx.lineWidth = 4;
        ctx.setLineDash([18, 18]);
        for (let i = 1; i < LANES; i++) {
          const x = laneX[i] - (laneX[i] - laneX[i - 1]) / 2;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, H);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      function drawBall(x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(x + r * 0.35, y - r * 0.35, r * 0.55, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      function drawObstacle(x, y, h, color) {
        // Draw a full lane width obstacle
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.rect(x - laneW / 2, y - h / 2, laneW, h); 
        ctx.fill();
      }

      function fmt(n) {
        return Number.isInteger(n) ? n.toString() : n.toFixed(1);
      }

      function resize() {
        const wrap = document.getElementById('wrap');
        const rect = wrap.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        W = canvas.width;
        H = canvas.height;
        laneW = Math.floor(W * 0.22);
        const gap = (W - laneW * LANES) / (LANES + 1);
        laneX = Array.from({ length: LANES }, (_, i) => Math.floor(gap + i * (laneW + gap)) + laneW / 2);
        player.w = laneW * 0.9;
        player.h = player.w;
        player.y = H - player.h - 30;
        player.x = laneX[player.lane];
        player.targetX = laneX[player.lane];
      }
      window.addEventListener('resize', resize);
      window.addEventListener('orientationchange', resize);

      // --- Player (Shrimp) Logic ---
      function moveLane(dir) {
        if (running) {
          player.lane = Math.max(0, Math.min(LANES - 1, player.lane + dir));
          // Lane change happens instantly when a key is pressed
          player.x = laneX[player.lane];
          player.targetX = laneX[player.lane];
        }
      }
      window.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') moveLane(-1);
        if (e.key === 'ArrowRight') moveLane(1);
      });

      // --- Spawning and Movement Logic ---
      function rngKind() {
        const r = Math.random();
        let acc = 0;
        for (const b of BALLS) {
          acc += b.p;
          if (r <= acc) return b;
        }
        return BALLS[BALLS.length - 1];
      }

      function spawnBall() {
        const lane = Math.floor(Math.random() * LANES);
        const kind = rngKind();
        const dropRadius = Math.max(10, laneW * 0.12);
        drops.push({ type: 'ball', lane, y: -dropRadius, r: dropRadius, kind });
      }

      function spawnObstacle() {
        const obsHeight = Math.max(20, laneW * 0.2);
        
        // 25% chance to spawn obstacles in two lanes
        if (Math.random() < 0.25) {
          const lane1 = Math.floor(Math.random() * LANES);
          let lane2 = Math.floor(Math.random() * LANES);
          while(lane2 === lane1) { // Ensure the second lane is different
            lane2 = Math.floor(Math.random() * LANES);
          }
          drops.push({ type: 'obstacle', lane: lane1, y: -obsHeight, h: obsHeight });
          drops.push({ type: 'obstacle', lane: lane2, y: -obsHeight, h: obsHeight });
        } else {
          // Normal spawn is a single obstacle
          const lane = Math.floor(Math.random() * LANES);
          drops.push({ type: 'obstacle', lane, y: -obsHeight, h: obsHeight });
        }

        // Add some randomness to obstacle spawning period
        obstacleSpawnPeriod = 700 + Math.random() * 500;
      }

      // --- Game Over / Win Logic ---
      const endOverlay = document.getElementById('endOverlay');
      const howToPlayOverlay = document.getElementById('howToPlayOverlay');
      const startButton = document.getElementById('startButton');
      const endTitle = document.getElementById('endTitle');
      const endStats = document.getElementById('endStats');
      const retryBtn = document.getElementById('retry-btn');
      const continueBtn = document.getElementById('continue-btn');
      const exitBtn = document.getElementById('exit-btn');

      startButton.addEventListener('click', () => { reset(); });
      retryBtn.addEventListener('click', () => { reset(); });
      continueBtn.addEventListener('click', () => { continueGame(); });
      exitBtn.addEventListener('click', () => {
        // Show the how to play screen and stop the game
        endOverlay.style.display = 'none';
        howToPlayOverlay.style.display = 'flex';
        running = false;
      });

      function showGameOver() {
        endTitle.textContent = 'Game Over!';
        // Score is multiplied by 10 and shown
        endStats.textContent = `Your Score: ${fmt(score * 10)}`;
        continueBtn.style.display = 'none';
        endOverlay.style.display = 'flex';
        running = false;
      }
      
      function showWin() {
        endTitle.textContent = 'Congratulations, You Completed the Goal!';
        // Special message for passing 200 points
        endStats.textContent = `You passed 200 points! Your total score: ${fmt(score * 10)}`;
        continueBtn.style.display = 'inline-block';
        endOverlay.style.display = 'flex';
        running = false;
      }

      // --- Game Loop and Core Logic ---
      let running = false, lastTime = 0;

      function reset() {
        running = false;
        lastTime = 0;
        score = 0;
        lives = 3;
        speed = 0.5; // Reset to slow starting speed
        nextSpeedIncreaseIndex = 0; // Speed increase tracker reset
        drops.length = 0;
        player.isInvulnerable = false;
        invulnerabilityTimer = 0;
        endOverlay.style.display = 'none';
        howToPlayOverlay.style.display = 'none';
        resize();
        requestAnimationFrame(loop);
      }

      function continueGame() {
        running = false;
        lastTime = 0;
        score = 0;
        speed = 0.5;
        nextSpeedIncreaseIndex = 0;
        drops.length = 0;
        player.isInvulnerable = false;
        invulnerabilityTimer = 0;
        endOverlay.style.display = 'none';
        resize();
        requestAnimationFrame(loop);
      }

      function loop(t) {
        if (!running) {
          running = true;
          lastTime = t || performance.now();
        }
        const dt = Math.min(32, (t || performance.now()) - lastTime);
        lastTime = t || performance.now();

        // Invulnerability flicker timer
        if (player.isInvulnerable) {
          invulnerabilityTimer += dt;
          if (invulnerabilityTimer >= invulnerabilityDuration) {
            player.isInvulnerable = false;
            invulnerabilityTimer = 0;
          }
        }

        // Spawning logic
        ballSpawnTimer += dt;
        if (ballSpawnTimer >= ballSpawnPeriod) {
          spawnBall();
          ballSpawnTimer = 0;
        }
        obstacleSpawnTimer += dt;
        if (obstacleSpawnTimer >= obstacleSpawnPeriod) {
          spawnObstacle();
          obstacleSpawnTimer = 0;
        }

        // Movement
        const vy = (speed * dt * H) / 700;
        for (const d of drops) {
          d.y += vy;
        }

        // Collision detection and cleanup
        const py = player.y + player.h * 0.5;
        const pr = Math.min(player.w, player.h) * 0.4;
        
        for (let i = drops.length - 1; i >= 0; i--) {
          const d = drops[i];
          // Check for collision in the same lane
          if (d.lane === player.lane) {
            let collided = false;
            if (d.type === 'ball') {
              const dist = Math.hypot(laneX[d.lane] - player.x, d.y - py);
              collided = dist < d.r + pr;
            } else if (d.type === 'obstacle') {
              const obsY = d.y + d.h / 2;
              const obsHalfHeight = d.h / 2;
              collided = Math.abs(py - obsY) < (pr + obsHalfHeight);
            }
            
            if (collided) {
              if (d.type === 'ball') {
                score += d.kind.score;
                drops.splice(i, 1);
                
                // Increase speed when score goals are met
                if (nextSpeedIncreaseIndex < speedIncreaseScores.length && score >= speedIncreaseScores[nextSpeedIncreaseIndex]) {
                  speed = Math.min(MAX_SPEED, speed + SPEED_INCREASE_AMOUNT);
                  nextSpeedIncreaseIndex++;
                }

              } else if (d.type === 'obstacle') {
                if (!player.isInvulnerable) {
                  lives--;
                  player.isInvulnerable = true;
                  invulnerabilityTimer = 0;
                  if (lives <= 0) {
                    showGameOver();
                    // Don't break here, allow cleanup to continue
                  }
                }
                // An obstacle now persists after collision, so we don't splice it.
              }
            }
          }
        }

        // Screen boundary cleanup
        for (let i = drops.length - 1; i >= 0; i--) {
          if (drops[i].y > H + drops[i].r) {
            drops.splice(i, 1);
          }
        }

        // Check for win condition
        if (score >= TARGET_SCORE) {
          showWin();
        }

        // --- Drawing ---
        ctx.clearRect(0, 0, W, H);
        drawBackground();
        
        // Draw player (Shrimp emoji)
        const pY = player.y + player.h * 0.5;

        // Apply flicker effect if invulnerable
        if (!player.isInvulnerable || (player.isInvulnerable && invulnerabilityTimer % 200 < 100)) {
          ctx.fillStyle = getCssVar('--text');
          ctx.font = `bold ${player.w * 0.7}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('ü¶ê', player.x, pY);
        }
        
        // Draw balls and obstacles
        for (const d of drops) {
          if (d.type === 'ball') {
            drawBall(laneX[d.lane], d.y, d.r, getCssVar(d.kind.color));
          } else if (d.type === 'obstacle') {
            drawObstacle(laneX[d.lane], d.y, d.h, getCssVar('--obs-color'));
          }
        }

        // Draw HUD
        ctx.fillStyle = getCssVar('--text');
        ctx.font = 'bold 16px system-ui';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top'; // Reset text baseline
        ctx.fillText(`Score: ${fmt(score)} / ${TARGET_SCORE}`, 12, 22);
        ctx.fillText(`Lives: ${lives}`, 12, 44);

        if (running) {
          requestAnimationFrame(loop);
        }
      }

      // Initial call to show how to play screen
      resize();
    })();
  </script>
</body>
</html>
